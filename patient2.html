<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TREATED CENTREES</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .character_spritesheet {
            position: absolute;
            background: url("https://assets.codepen.io/21542/DemoRpgCharacter.png") no-repeat no-repeat;
            background-size: 100%;
            width: calc( var(--grid-cell)* 8 );
            height: calc( var(--grid-cell)* 8 );
        }

        .interactable.npc {
            width: calc(var(--grid-cell) * 2);
            height: calc(var(--grid-cell) * 2);
            background-image: url('Dmentia.png');
            background-position: center bottom;
        }

        .interactable.bookshelf {
            width: calc(var(--grid-cell) * 2);
            height: calc(var(--grid-cell) * 2);
            background-position: center bottom;
        }

        .interactable.move {
            width: calc(var(--grid-cell) * 2);
            height: calc(var(--grid-cell) * 2);
            background-image: url('move3.gif');
            background-position: center bottom;
            display: none;
        }
        .interactable {
            outline: none;
        }

        .map {
            image-rendering: pixelated;
            background-image: url("patient2.png");
            background-size: 100%;
            width: calc(13 * var(--grid-cell));
            height: calc(10 * var(--grid-cell));
            position: relative;
        }

        .shadow {
            display: none;
        }
    </style>
</head>
<body>

    <div class="dialogue-box" id="dialogueBox">
        <p id="dialogueText"></p>
        <button class="next-button" id="nextBtn">Next</button>
    </div>

    <div class="frame">
        <div class="corner_topleft"></div>
        <div class="corner_topright"></div>
        <div class="corner_bottomleft"></div>
        <div class="corner_bottomright"></div>

        <div class="camera">
            <div class="map pixel-art" id="map">
                <div id="nurse" class="interactable npc" data-name="Old Man" data-x="80" data-y="100"></div>
                <div class="interactable bookshelf" data-name="Dusty Bookshelf" data-x="200" data-y="50"></div>
                <div id="move" class="interactable move" data-name="move" data-x="200" data-y="50"></div>

                <div class="character" facing="down" walking="true" id="character">
                    <div class="shadow pixel-art"></div>
                    <div class="character_spritesheet pixel-art"></div>
                </div>
            </div>
        </div>
    </div>

    <audio id="dialogueSound" src="next.wav" preload="auto"></audio>
    
    <script>
        const character = document.getElementById("character");
        const map = document.getElementById("map");
        const dialogueBox = document.getElementById("dialogueBox");
        const dialogueTextContainer = document.getElementById("dialogueText");
        const nextBtn = document.getElementById("nextBtn");
        const dialogueSound = document.getElementById("dialogueSound");
        let onDialogueEndFunction = null;

        var characterX = 87;
        var characterY = 124;
        var held_directions = [];
        var characterSpeed = 0.25;

        let isTyping = false;
        let currentDialogueIndex = 0;
        let currentDialogueSet = [];
        let isDialogueActive = false;

        const interactablesData = [
            {
                name: "Old Man",
                x: 60,
                y: 54,
                width: 40,
                height: 40,
                dialogues: [
                    "I Know I am forgetting something. Don't Mentia-n it!",
                    "Haha, ha ha... forgetting something. My memories keep drifting out of reach.",
                    "Not that it matters much. I am a pumpkin, after all."
                ],
                interactionRange: 25,
                onInteraction: "changeColor"
            },
            {
                name: "Dusty Bookshelf",
                x: 110,
                y: 54,
                width: 40,
                height: 40,
                dialogues: [
                    "The patient appears to be a pair of sneakers that have been creased.",
                    "*You begin to really admire the heroism of the hospital"
                ],
                interactionRange: 25
            },
            
            {
                name: "move",
                x: 87,
                y: 124,
                width: 32,
                height: 32,
                dialogues: [
                ],
                interactionRange: 20,
                onInteraction: "move"
            },
        ];

        function ChangeColor () {
        }

        function move() {
            window.location.href = "mainhospital2.html"
        }

        function getInteractionFunction(functionName) {
            switch (functionName) {
                case "changeColor":
                    return ChangeColor;
                case "move":
                    return move;
                default:
                    return null;
            }
        }

        function getPixelSize() {
            return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pixel-size'));
        }

        function calculateDistance(x1, y1, x2, y2) {
            const dx = x1 - x2;
            const dy = y1 - y2;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function startDialogue(dialogueSet, onEndCallback = null) {
            isDialogueActive = true;
            currentDialogueSet = dialogueSet;
            currentDialogueIndex = 0;
            onDialogueEndFunction = onEndCallback;
            dialogueBox.style.display = 'block';
            nextDialogueLine();
        }
        
        function nextDialogueLine() {
            if (isTyping) {
                clearTimeout(typeTextTimeout);
                dialogueTextContainer.innerHTML = currentDialogueSet[currentDialogueIndex - 1];
                isTyping = false;
                return;
            }

            if (currentDialogueIndex < currentDialogueSet.length) {
                typeText(currentDialogueSet[currentDialogueIndex]);
                playDialogueSound();
                currentDialogueIndex++;
            } else {
                endDialogue();
            }
        }

        let typeTextTimeout;

        function typeText(text) {
            dialogueTextContainer.innerHTML = "";
            let charIndex = 0;
            isTyping = true;

            function typeNextChar() {
                if (charIndex < text.length) {
                    dialogueTextContainer.innerHTML += text[charIndex];
                    charIndex++;
                    typeTextTimeout = setTimeout(typeNextChar, 50);
                } else {
                    isTyping = false;
                }
            }
            typeNextChar();
        }

        function playDialogueSound() {
            dialogueSound.currentTime = 0;
            dialogueSound.play().catch(e => console.log("Audio play blocked:", e));
        }

        function endDialogue() {
            dialogueBox.style.display = 'none';
            isDialogueActive = false;
            currentDialogueSet = [];

            if (onDialogueEndFunction && typeof onDialogueEndFunction === 'function') {
                onDialogueEndFunction();
                onDialogueEndFunction = null;
            }
        }

        function handleInteraction(interactable) {
            let dialogueSet;
            const onEndCallback = () => {
                const functionToCall = getInteractionFunction(interactable.onInteraction);
                if (functionToCall) {
                    functionToCall();
                }
            };
            
            if (interactable.hasOwnProperty('hasInteracted')) {
                dialogueSet = interactable.hasInteracted ? interactable.dialogues.revisited : interactable.dialogues.initial;
                
                const originalCallback = onEndCallback;
                onEndCallback = () => {
                    originalCallback();
                    interactable.hasInteracted = true;
                };

                startDialogue(dialogueSet, onEndCallback);

            } else if (interactable.dialogues && interactable.dialogues.length > 0) {
                dialogueSet = interactable.dialogues;
                
                startDialogue(dialogueSet, onEndCallback);

            } else if (interactable.onInteraction) {
                const functionToCall = getInteractionFunction(interactable.onInteraction);
                if (functionToCall) {
                    functionToCall();
                }
            }
        }

        nextBtn.addEventListener("click", nextDialogueLine);

        const directions = {
            up: "up",
            down: "down",
            left: "left",
            right: "right",
        }
        const keys = {
            38: directions.up,
            37: directions.left,
            39: directions.right,
            40: directions.down,
            87: directions.up,
            65: directions.left,
            83: directions.down,
            68: directions.right,
            69: "interact"
        }

        const placeCharacter = () => {
            if (isDialogueActive) return;

            var pixelSize = getPixelSize();

            const held_direction = held_directions[0];
            if (held_direction) {
                if (held_direction === directions.right) { characterX += characterSpeed; }
                if (held_direction === directions.left) { characterX -= characterSpeed; }
                if (held_direction === directions.down) { characterY += characterSpeed; }
                if (held_direction === directions.up) { characterY -= characterSpeed; }
                character.setAttribute("facing", held_direction);
            }
            character.setAttribute("walking", held_direction ? "true" : "false");

            var leftLimit = 30;
            var rightLimit = (16 * 11) + -35;
            var topLimit = -8 + 32;
            var bottomLimit = (16 * 7);

            if (characterX < leftLimit) { characterX = leftLimit; }
            if (characterX > rightLimit) { characterX = rightLimit; }
            if (characterY < topLimit) { characterY = topLimit; }
            if (characterY > bottomLimit) { characterY = bottomLimit; }

            var camera_left = pixelSize * 66;
            var camera_top = pixelSize * 42;

            map.style.transform = `translate3d( ${-characterX * pixelSize + camera_left}px, ${-characterY * pixelSize + camera_top}px, 0 )`;
            character.style.transform = `translate3d( ${characterX * pixelSize}px, ${characterY * pixelSize}px, 0 )`;
        }

        const step = () => {
            placeCharacter();
            window.requestAnimationFrame(() => {
                step();
            })
        }
        step();

        document.addEventListener("keydown", (e) => {
            const dir = keys[e.which];

            if (dir === "interact") {
                if (isDialogueActive) {
                    nextDialogueLine();
                } else {
                    let closestInteractable = null;
                    let minDistance = Infinity;

                    interactablesData.forEach(obj => {
                        const objElement = map.querySelector(`[data-name="${obj.name}"]`);
                        if (objElement) {
                            const charCenterX = characterX + (parseInt(getComputedStyle(character).width) / (2 * getPixelSize()));
                            const charCenterY = characterY + (parseInt(getComputedStyle(character).height) / (2 * getPixelSize()));

                            const objCenterX = obj.x + (obj.width / 2);
                            const objCenterY = obj.y + (obj.height / 2);

                            const distance = calculateDistance(charCenterX, charCenterY, objCenterX, objCenterY);

                            if (distance <= obj.interactionRange && distance < minDistance) {
                                minDistance = distance;
                                closestInteractable = obj;
                            }
                        }
                    });

                    if (closestInteractable) {
                        handleInteraction(closestInteractable);
                    }
                }
            } else if (dir && held_directions.indexOf(dir) === -1 && !isDialogueActive) {
                held_directions.unshift(dir);
            }
        });

        document.addEventListener("keyup", (e) => {
            const dir = keys[e.which];
            const index = held_directions.indexOf(dir);
            if (index > -1) {
                held_directions.splice(index, 1);
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            const pixelSize = getPixelSize();

            interactablesData.forEach(obj => {
                const element = map.querySelector(`[data-name="${obj.name}"]`);
                if (element) {
                    element.style.left = `${obj.x * pixelSize}px`;
                    element.style.top = `${obj.y * pixelSize}px`;
                    element.style.width = `${obj.width * pixelSize}px`;
                    element.style.height = `${obj.height * pixelSize}px`;
                }
            });
        });
    </script>
</body>
</html>